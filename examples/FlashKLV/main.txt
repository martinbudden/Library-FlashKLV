#include <Arduino.h>

#include <FlashKLV.h>

#include <array>
#include <boards/pico.h>
#include <hardware/flash.h>
#include <hardware/sync.h>

enum { SECTOR_COUNT = 4 };
//static FlashKLV flashKLV(SECTOR_COUNT);
static constexpr size_t FLASH_ADDRESS = (XIP_BASE + PICO_FLASH_SIZE_BYTES - FlashKLV::SECTOR_SIZE*SECTOR_COUNT);
static FlashKLV flashKLV(reinterpret_cast<uint8_t*>(FLASH_ADDRESS), SECTOR_COUNT, FlashKLV::ONE_BANK);
std::array<uint8_t, FLASH_PAGE_SIZE> page;

enum { CONFIG_KEY = 0x01 };
struct config_t {
    uint16_t a;
    uint8_t b;
    uint8_t c;
};

void printBuf(const uint8_t *buf, size_t len)
{
    uint32_t count = 0;
    for (size_t ii = 0; ii < len; ++ii) {
        if (buf[ii] < 0x10) {
            Serial.print("0");
        }
        Serial.print(String(buf[ii], HEX));
        ++count;
        if (count == 6) {
            Serial.println();
            count = 0;
        } else {
            Serial.print(" ");
        }
    }
    Serial.println();
}

void setup()
{
    //stdio_init_all();
    Serial.begin(115200);
    while(!Serial);
    delay(1000);
    // create a FlashKLV object

    Serial.println("Creating FlashKLV object");
    Serial.println("FlashPtr:" + String(reinterpret_cast<uint32_t>(flashKLV.getCurrentBankMemoryPtr()), HEX));
    Serial.println("FlashPtr-XIP:" + String(reinterpret_cast<uint32_t>(flashKLV.getCurrentBankMemoryPtr()) - XIP_BASE, HEX));
    Serial.println("Offset:" + String(PICO_FLASH_SIZE_BYTES - FLASH_SECTOR_SIZE*SECTOR_COUNT, HEX));
    //printBuf(flashKLV.getCurrentBankMemoryPtr(), 18);
    // declare a key and structure

    // write s config structure to flash
    //const config_t configW = { .a = 713, .b =27, .c = 12 };
    //int32_t err = flashKLV.write(CONFIG_KEY, sizeof(configW), &configW);
    //Serial.println("write err = " + String(err, DEC));

}

void loop()
{
    static uint32_t count = 0;
    delay(100);
    if (count < 3) {
        Serial.println("Count:" + String(count, DEC));
        Serial.println("Flash:" + String(PICO_FLASH_SIZE_BYTES, DEC));
        ++count;
        printBuf(flashKLV.getCurrentBankMemoryPtr(), 36);
    }
    if (count == 1) {
        Serial.println("****WRITE****");
        delay(100);
        // write s config structure to flash


#if true
        const config_t configW = { .a = 0x0AFF, .b =0x12, .c = 0x35 };
        int32_t err = flashKLV.write(CONFIG_KEY, sizeof(configW), &configW);
        Serial.println("write err = " + String(err, DEC));
        //flashKLV.flashWrite(0, sizeof(configW), &configW);
#else
        std::array<uint8_t, 6> record = { 0x81, 0x04, 0x1A, 0x2B, 0x3C, 0x4D };
        page.fill(0xFF);
        memcpy(&page[0], &record[0], sizeof(record));
        memcpy(flashKLV.getPageCache(), &page[0], sizeof(page));
        //const uint32_t interrupts = save_and_disable_interrupts();
        flashKLV.flashWritePage(0);
        //flash_range_program(PICO_FLASH_SIZE_BYTES - FLASH_SECTOR_SIZE*SECTOR_COUNT, &page[0], FLASH_PAGE_SIZE);
        //restore_interrupts (interrupts);
#endif
    }
    if (count == 2) {
        // read a config structure
        Serial.println("****READ****");
        delay(100);
        config_t configR {};
        int err = flashKLV.read(&configR, sizeof(configR), CONFIG_KEY);
        Serial.println("read err = " + String(err, DEC));
        Serial.println("record:" + String(configR.a, HEX) + " "+ String(configR.b, HEX) + " " + String(configR.c, HEX));
    }
}